[Outline](README.md) | Previous: [Death Effects](C6.md) | Next: [Ladders](C8.md)

# 7) Game Controller

Create Game and Level controllers; tracking points, lives, and level respawn.

<img src=https://i.imgur.com/BgPwAYq.gif width=500px>

 - 7.1) [Create a GameController](#71-create-a-gamecontroller)
 - 7.2) [Stay on-screen](#72-stay-on-screen)
 - 7.3) [Bounce Off Edges](#73-bounce-off-edges)
 - 7.4) [Respawn Character](#74-respawn-character)
 - 7.5) [Clear Level on Death](#75-clear-level-on-death)
 - 7.6) [Points for Jumping Over Enemies](#76-points-for-jumping-over-enemies)

## 7.1) Create a GameController

[YouTube]() | [Source before](https://github.com/hardlydifficult/2DUnityTutorial/archive/DeathEffectAnimate.zip) | [Source after](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerCreate.zip)

Create a singleton GameController to track points, lives, and hold global data such as the world size.

<details><summary>How</summary>

**Create GameController**:

 - Create script Code/Controllers/**[GameController](https://github.com/hardlydifficult/2DUnityTutorial/blob/GameControllerCreate/Assets/Code/Controllers/GameController.cs)**:

```csharp
using System;
using UnityEngine;

public class GameController : MonoBehaviour
{
  public static GameController instance;

  public event Action onLifeCountChange;

  [SerializeField]
  int _lifeCount = 3;
  public int lifeCount
  {
    get
    {
      return _lifeCount;
    }
    set
    {
      _lifeCount = value;
      if(onLifeCountChange != null)
      {
        onLifeCountChange();
      }
    }
  }

  public int points;

  public Bounds screenBounds
  {
    get; private set;
  }

  int originalLifeCount;

  protected void Awake()
  {
    if(instance != null)
    {
      Destroy(gameObject);
      return;
    }

    instance = this;
    DontDestroyOnLoad(gameObject);

    originalLifeCount = lifeCount;

    CalcScreenSize();
  }

  protected void Update()
  {
    CalcScreenSize();
  }

  void CalcScreenSize()
  {
    Vector2 screenSize = new Vector2(
          (float)Screen.width / Screen.height,
          1);
    screenSize *= Camera.main.orthographicSize * 2;
    screenBounds = new Bounds(
      (Vector2)Camera.main.transform.position,
      screenSize);
  }
}
```

**Configure GameController**:

  - Create a new GameObject named "GameController":
    - Add the **GameController** component.

<br>**Create DeathEffectDecrementLives**:

 - Create script Code/Death/**[DeathEffectDecrementLives](https://github.com/hardlydifficult/2DUnityTutorial/blob/GameControllerCreate/Assets/Code/Controllers/DeathEffectDecrementLives.cs)**:

```csharp
public class DeathEffectDecrementLives : DeathEffect
{
  public override float PlayDeathEffects()
  {
    GameController.instance.lifeCount--;

    return 0;
  }
}
```

<br>**Configure Character**:

 - Add **DeathEffectDecrementLives** to the Character.

<br>**Test**:

 - Look at the life count in the GameController component.  Values in the Inspector will update in real-time.  When the Character dies, the value should go down.
   - Note that the GameController will move under a DontDestroyOnLoad section in the Hierarchy while playing.

<hr></details><br>
<details><summary>Explain the code</summary>

**GameController**:

using clauses at the top of a file brings APIs into scope. Used for:

 - System.Action
 - UnityEngine.Bounds
 - UnityEngine.Camera
 - UnityEngine.MonoBehaviour
 - UnityEngine.Screen
 - UnityEngine.SerializeFieldAttribute
 - UnityEngine.Vector2

```csharp
using System;
using UnityEngine;
```

We inherit from MonoBehaviour, which allows this script to be added as a component on a GameObject.

public is optional here. Used for consistency.

```csharp
public class GameController : MonoBehaviour
{
```

This holds a reference to the only GameController in the world.  It is public static so that other components can get to it easily.

```csharp
  public static GameController instance;
```

This is an event that other components may subscribe to.  When the life count changes, this event will be called.

```csharp
  public event Action onLifeCountChange;
```

This is a Unity-specific attribute that exposes a field in the Inspector, allowing you to configure it for the object.

```csharp
  [SerializeField]
```

This holds the current life count.

The underscore prefix is a style convention I use, indicating that this variable is data backing a property of the same same.

```csharp
  int _lifeCount = 3;
```

This is a public property that other components may use to get or set the current lifeCount (e.g. when the Character dies).

```csharp
  public int lifeCount
  {
```

This defines the get method for lifeCount, which is called anytime lifeCount is read.

```csharp
    get
    {
```

Here we simply return the data backing this property.

```csharp
      return _lifeCount;
    }
```

This defines the set method for lifeCount, which is called anytime lifeCount is changed.

```csharp
    set
    {
```

This stores the new value in the variable backing this property, specified with a special keyword in C# for attributes called 'value'.

```csharp
      _lifeCount = value;
```

This will call method(s) which have registered with the onLifeCountChange event.  If no methods are currently registered, this variable will be null which is why we check for that first.

```csharp
      if(onLifeCountChange != null)
      {
        onLifeCountChange();
      }
    }
  }
```

This is a public variable tracking the number of points the player has earned.  Any component may read or write to this value.

```csharp
  public int points;
```

This stores the visible area of the screen.  Here so that it may be calculated once and reused by components, for performance.

```csharp
  public Bounds screenBounds
  {
    get; private set;
  }
```

This stores the original value for _lifeCount.  With this, we can reset the lives when the player begins a new game.

```csharp
  int originalLifeCount;
```

Awake is a Unity event which is called once, the first time the GameObject is added to a scene.

```csharp
  protected void Awake()
  {
```

This checks if there is already an active GameController.

```csharp
    if(instance != null)
    {
```

If there is already another GameController, destroy this as we don't want a second to remain in the Scene.

```csharp
      Destroy(gameObject);
```

Here we return so the code below is not executed.  You could have used an else block around the remaining code instead, this is a style preference.

```csharp
      return;
    }
```

Here we store the reference to this GameController, for other components to use.

```csharp
    instance = this;
```

DontDestroyOnLoad is a Unity method which sets a flag on this GameObject, preventing it from being destroyed when the scene changes.

```csharp
    DontDestroyOnLoad(gameObject);
```

Here we store the original number of lives, allowing us to reset back to this value when the player restarts the game.

```csharp
    originalLifeCount = lifeCount;
```

Here we call a helper method defined below to update the screenBounds.  We do this in Awake so that screenBounds is valid the first time another component tries to use it.

```csharp
    CalcScreenSize();
  }
```

Update is a Unity event which is called once per frame.

protected is optional here.  Used for consistency.

```csharp
  protected void Update()
  {
```

Here we call a helper method defined below to update the screenBounds.  We do this every frame in case the camera has moved or changed sizes, possible due to changing scenes.

```csharp
    CalcScreenSize();
  }
```

This is a helper method to calculate screenBounds, the visible area of the world.

```csharp
  void CalcScreenSize()
  {
```

Here we first determine the screen's aspect ratio.

```csharp
    Vector2 screenSize = new Vector2(
          (float)Screen.width / Screen.height,
          1);
```

The aspect ratio is then multiplied by the screen size, giving us the size of the visible world.

```csharp
    screenSize *= Camera.main.orthographicSize * 2;
```

This sets the screenBounds using the camera's 2D position (so that Z becomes 0) as the center and the size calculated above.  

```csharp
    screenBounds = new Bounds(
      (Vector2)Camera.main.transform.position,
      screenSize);
  }
}
```

<br>**DeathEffectDecrementLives**:

We inherit from DeathEffect which is a MonoBehaviour, which allows this script to be added as a component on a GameObject. 

public is optional here. Used for consistency.

```csharp
public class DeathEffectDecrementLives : DeathEffect
{
```

This overrides DeathEffect's method which will be called when this GameObject dies.

```csharp
  public override float PlayDeathEffects()
  {
```

Here we decrement the current life count, tracked by the GameController.

```csharp
    GameController.instance.lifeCount--;
```

Returns 0, indicating that the GameObject may be destroyed at any time.

```csharp
    return 0;
  }
}
```

</details>
<details><summary>What does DontDestroyOnLoad do?</summary>

DontDestroyOnLoad is a Unity method which marks a GameObject as independent from the scene you are in.  This means when we change scenes, the GameObject is not destroyed like everything else in the scene.

While in play mode, Unity moves the GameObject to a DontDestroyOnLoad section in the Hierarchy.

In order to simplify development, we will be putting a GameController GameObject in every scene -- as opposed to defining one in the world, maybe at the Main Menu or in Level 1 only.  This way when we test a specific scene, such as level 2, the GameController is available.

To ensure only one GameController at a time, in Awake we destroy the extra GameController if one is already available.

<hr></details>
<details><summary>What's a singleton and why use it?</summary>

Singleton is a common design pattern.  When there is only going to be one of something, the singleton pattern provides an easy way of accessing that object from other scripts -- a public static 'instance'.

You could have used GameObject.Find (or one of its variations) instead.  Since several components will be accessing the GameController, using singleton here simplifies the code and improves performance a bit.

Here's a [good article about singleton from dotnetperls](https://www.dotnetperls.com/singleton).

<hr></details>
<details><summary>Why is there an entire class for basically one line of code?</summary>

It's a way of getting the event we need without adding this logic to a loosely related component.  Obviously there are other ways you could tackle this problem; I like the simplicity here.

Note the timing for this event before considering an alternate solution.  We are decrementing lives as soon as something touches the Character, as opposed to after the death effect animation completes (which is the timing you would get by using OnDestroy).

<hr></details>

## 7.2) Stay on-screen

[YouTube]() | [Source before](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerCreate.zip) | [Source after](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerKeepOnScreen.zip)

Create a script which ensures entities can not walk off-screen.

<details><summary>How</summary>

**Create KeepOnScreen**:

 - Create script Code/Movement/**[KeepOnScreen](https://github.com/hardlydifficult/2DUnityTutorial/blob/GameControllerKeepOnScreen/Assets/Code/Movement/KeepOnScreen.cs)**:

```csharp
using System;
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
public class KeepOnScreen : MonoBehaviour
{
  Rigidbody2D myBody;

  public event Action onAttemptToLeaveScreen;

  protected void Awake()
  {
    myBody = GetComponent<Rigidbody2D>();
  }

  protected void FixedUpdate()
  {
    Bounds screenBounds = GameController.instance.screenBounds;
    if(screenBounds.Contains(transform.position) == false)
    {
      transform.position =
        screenBounds.ClosestPoint(transform.position);
      if(onAttemptToLeaveScreen != null)
      {
        onAttemptToLeaveScreen();
      }
    }
  }
}
```

<br>**Configure entities**:

 - Add **KeepOnScreen** to both the Character and the HoverGuy prefab.

<br>**Test**:

 - The Character should not be able to walk off-screen.
 - The HoverGuy also should not walk off, but he may keep trying - that will be addressed next.

<hr></details><br>
<details><summary>Explain the code</summary>

using clauses at the top of a file brings APIs into scope. Used for:

 - System.Action
 - UnityEngine.RequireComponentAttribute
 - UnityEngine.Rigidbody2D
 - UnityEngine.MonoBehaviour
 - UnityEngine.Bounds

```csharp
using System;
using UnityEngine;
```

This is a Unity-specific attribute which informs the editor that this script requires a collider component on the GameObject.

```csharp
[RequireComponent(typeof(Rigidbody2D))]
```

We inherit from MonoBehaviour, which allows this script to be added as a component on a GameObject.

public is optional here. Used for consistency.

```csharp
public class KeepOnScreen : MonoBehaviour
{
```

This holds a reference to the rigidbody for this GameObject.  Here for performance.

```csharp
  Rigidbody2D myBody;
```

This is a public event other components may subscribe to in order to be called anytime this entity hits the side of the screen.

```csharp
  public event Action onAttemptToLeaveScreen;
```

Awake is a Unity event which is called once, the first time a GameObject is added to the scene.

protected is optional here.  Used for consistency.

```csharp
  protected void Awake()
  {
```

This gets a reference to the rigidbody on this GameObject.

```csharp
    myBody = GetComponent<Rigidbody2D>();
  }
```

FixedUpdate is a Unity event which is called ever x ms of game time.

protected is optional here.  Used for consistency.

```csharp
  protected void FixedUpdate()
  {
```

Check if the entity is currently outside of the visible area on the screen, using the screenBounds calculated in the GameController.

```csharp
    Bounds screenBounds = GameController.instance.screenBounds;
    if(screenBounds.Contains(transform.position) == false)
    {
```

This will reposition the GameObject so that it is on-screen, using the on-screen which is closest to the GameObject's current position.

```csharp
      transform.position =
        screenBounds.ClosestPoint(transform.position);
```

Call method(s) which have registered for this event.  If no other component has registered, this will be null which is why we start with that if check.

```csharp
      if(onAttemptToLeaveScreen != null)
      {
        onAttemptToLeaveScreen();
      }
    }
  }
}
```

</details>
<details><summary>Why use bounds for these checks?</summary>

There are a few ways you could check for an entity walking off the edge of the screen.  I choose to use the Unity bounds struct because it has methods which make the rest of this component easy.  Specifically:

 - Contains: Check if the current position is on the screen.
 - ClosestPoint: Return the closest point on-screen for the entity, used when it is off-screen to teleport it back.

<hr></details>
<details><summary>What's the difference between setting transform.position and using myBody.MovePosition?</summary>

Updates to the Transform directly will teleport your character immediately and bypass all physics logic.

Using the rigidbody.MovePosition method will interpolate (i.e., smoothly transition) the object to its new position and give consideration to other forces on that object.  It's very fast, but if you try and watch closely, MovePosition may animate a few frames on the way to the target position instead of going there immediately.

We are not suggesting one approach should always be used over the other - consider the use case and how you want your game to feel, sometimes teleporting is exactly the feature you're looking for.

Be careful when you change position using either of these methods as opposed to using forces on the rigidbody.  It's possible that you teleport right into the middle of another object.  The next frame, Unity will try to react to that collision state and this may result in objects popping out in strange ways.

In this component we are setting transform.position for the teleport effect.  If rigidbody.MovePosition was used instead, occasionally issues may arise as MovePosition competes with other forces on the object.

<hr></details>
<details><summary>Does setting the position cause the entity to pop on-screen?</summary>

Since this is checked every FixedUpdate, the teleporting effect that using transform.positions creates does not cause popping on the screen.  Typically this has the impact of undoing the move which would have occurred if not for this script.

<hr></details>
<details><summary>Why use an event when another component could check screen bounds again?</summary>

When a GameObject is teleported by this script, an event is fired.  This event allows other components to add additional logic to be executed when an entity attempts to leave the screen.  For example, in the next section we will be asking the HoverGuy to turn around and start walking the other way.

2 reasons.

Encourage reuse.  If our definition of leaving the screen changes, it would be best if that was contained in a single script.  For example, ATM half of the entity's body goes off-screen before we consider it to be out of bounds.  We may want to change that in the future to use the entity's collider bounds to ensure that the entire body stays visible.

It may not work reliably.  If both components checked screen bounds independently, the result may differ depending on which of those components executed first.  For example, KeepOnScreen may teleport you back on-screen and then BounceOffScreenEdges would not consider you out of bounds (and therefore not turn you around.)  You could make this work by modifying the 'Script Execution Order', but I prefer reusing the KeepOnScreen component.

<hr></details>

## 7.3) Bounce Off Edges

[YouTube]() | [Source before](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerKeepOnScreen.zip) | [Source after](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerTurnAround.zip)

Create a script to have the HoverGuy bounce off the edge of the screen and never stop walking.

<details><summary>How</summary>

**Create BounceOffScreenEdges**:

 - Create script Code/Movement/**[BounceOffScreenEdges](https://github.com/hardlydifficult/2DUnityTutorial/blob/GameControllerTurnAround/Assets/Code/Movement/BounceOffScreenEdges.cs)**:

```csharp
using UnityEngine;

[RequireComponent(typeof(KeepOnScreen))]
[RequireComponent(typeof(WalkMovement))]
public class BounceOffScreenEdges : MonoBehaviour
{
  WalkMovement walkMovement;

  protected void Awake()
  {
    walkMovement = GetComponent<WalkMovement>();
  }

  protected void Start()
  {
    KeepOnScreen keepOnScreen = GetComponent<KeepOnScreen>();
    keepOnScreen.onAttemptToLeaveScreen
      += KeepOnScreen_onAttemptToLeaveScreen;
  }

  void KeepOnScreen_onAttemptToLeaveScreen()
  {
    walkMovement.desiredWalkDirection = 
      transform.position.x > 0 ? -1 : 1;
  }
}
```

<br>**Configure HoverGuy**:

 - Add **BounceOffScreenEdges** to the HoverGuy prefab.

<br>**Test**:

  - When a HoverGuy reaches the edge, it should turn around so that it never stops moving.

<hr></details><br>
<details><summary>Explain the code</summary>

using clauses at the top of a file brings APIs into scope. Used for:

 - UnityEngine.MonoBehaviour
 - UnityEngine.RequireComponentAttribute

```csharp
using UnityEngine;
```

These are Unity-specific attributes which inform the editor that this script requires a collider component on the GameObject.

```csharp
[RequireComponent(typeof(KeepOnScreen))]
[RequireComponent(typeof(WalkMovement))]
```

We inherit from MonoBehaviour, which allows this script to be added as a component on a GameObject.

public is optional here. Used for consistency.

```csharp
public class BounceOffScreenEdges : MonoBehaviour
{
```

This is a reference to the WalkMovement component on this GameObject.  Cached here for performance.

```csharp
  WalkMovement walkMovement;
```

Awake is a Unity event which is called once, the first time the GameObject is added to the scene.

```csharp
  protected void Awake()
  {
```

This gets a reference to the WalkMovement component on this GameObject.

```csharp
    walkMovement = GetComponent<WalkMovement>();
  }
```

Start is a Unity event which is called once, the first time the component is enabled.

```csharp
  protected void Start()
  {
```

Gets a reference to the KeepOnScreen component on this GameObject.

```csharp
    KeepOnScreen keepOnScreen = GetComponent<KeepOnScreen>();
```

This subscribes for the event, to get a call every time this GameObject hits the side of the visible world.

```csharp
    keepOnScreen.onAttemptToLeaveScreen
      += KeepOnScreen_onAttemptToLeaveScreen;
  }
```

This is the method which is called by the event we subscribed to above.

```csharp
  void KeepOnScreen_onAttemptToLeaveScreen()
  {
```

This will set the walk direction to target the center of the screen.  If the x is positive we are currently on the right half of the screen and should walk left, and vice versa.

```csharp
    walkMovement.desiredWalkDirection = 
      transform.position.x > 0 ? -1 : 1;
  }
}
```

</details>
<details><summary>Why not register for the event on Awake?</summary>

You could.  This is a best practice.

The Unity event Awake occurs for all components in the Scene when the Scene is first loaded, even if the component is disabled.  Start occurs once, like Awake, but not until the first time the component is enabled.

We are using Start to register the event so that we do not unintentionally react to an event before this component is ready to act.

<hr></details>

## 7.4) Respawn Character

[YouTube]() | [Source before](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerTurnAround.zip) | [Source after](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerRespawn.zip)

Add scripts to destroy the enemies and respawn the character when he dies.

<details><summary>How</summary>

**Create LevelController**:

 - Create script Code/Controllers/**[LevelController](https://github.com/hardlydifficult/2DUnityTutorial/blob/GameControllerRespawn/Assets/Code/Controllers/LevelController.cs)**:

```csharp
using UnityEngine;

public class LevelController : MonoBehaviour
{
  [SerializeField]
  GameObject characterPrefab;

  bool isGameOver;

  protected void Start()
  {
    GameController.instance.onLifeCountChange
      += Instance_onLifeCounterChange;

    StartLevel();
  }

  protected void OnDestroy()
  {
    GameController.instance.onLifeCountChange
      -= Instance_onLifeCounterChange;
  }

  void Instance_onLifeCounterChange()
  {
    if(isGameOver)
    {
      return;
    }

    if(GameController.instance.lifeCount <= 0)
    {
      isGameOver = true;
      YouLose();
    }
    else
    {
      StartLevel();
    }
  }

  public void YouWin()
  {
    if(isGameOver == true)
    {
      return;
    }
    isGameOver = true;

    // TODO
  }

  void StartLevel()
  {
    Instantiate(characterPrefab);
  }

  void YouLose()
  {
    // TODO
  }
}
```

<br>**Create a Character prefab**:

 - Select the Character GameObject:
   - Position it over the door.
   - Create a prefab for the Character.
   - Delete the GameObject.

<br>**Configure LevelController**:

 - Add a GameObject named "LevelController":
   - Character Prefab: Character

<br>**Test**:

 - After you die, the Character should respawn up to 3 times.  
   - Once you are out of lives, nothing happens and you have to stop / start again.
   - You may spawn in on top of an enemy and die instantly.  This will be addressed next.

<hr></details><br>
<details><summary>Explain the code</summary>

using clauses at the top of a file brings APIs into scope. Used for:

 - UnityEngine.GameObject
 - UnityEngine.MonoBehaviour
 - UnityEngine.SerializeFieldAttribute

```csharp
using UnityEngine;
```

We inherit from MonoBehaviour, which allows this script to be added as a component on a GameObject.

public is optional here. Used for consistency.

```csharp
public class LevelController : MonoBehaviour
{
```

This is a Unity-specific attribute that exposes a field in the Inspector, allowing you to configure it for the object.

```csharp
  [SerializeField]
```

This is a reference to the prefab of the Character to instantiate.  Set in the Inspector.

```csharp
  GameObject characterPrefab;
```

This tracks if the game has already ended.

```csharp
  bool isGameOver;
```

Start is a Unity event which is called once, the first time this component is enabled.

```csharp
  protected void Start()
  {
```

Here we subscribe to the GameController event which will call the method below anytime the number of lives change.

```csharp
    GameController.instance.onLifeCountChange
      += Instance_onLifeCounterChange;
```

This calls the helper method below to start the level.

```csharp
    StartLevel();
  }
```

OnDestroy is a Unity method which is called when this GameObject is destroyed.

protected is optional here.  Used for consistency.

```csharp
  protected void OnDestroy()
  {
```

Here we are unsubscribing from the GameController event, preventing a memory leak.

```csharp
    GameController.instance.onLifeCountChange
      -= Instance_onLifeCounterChange;
  }
```

This is the method which is called by the GameController's event when the number of lives change.

```csharp
  void Instance_onLifeCounterChange()
  {
```

If the game has already ended, return so not to trigger end of level effects twice.

```csharp
    if(isGameOver)
    {
      return;
    }
```

Check if the player just lost their last life.

```csharp
    if(GameController.instance.lifeCount <= 0)
    {
```

The player is out of lives, here we track that the game is now over.

```csharp
      isGameOver = true;
```

This calls the helper method below to end the game.

```csharp
      YouLose();
    }
```

If the player is not out of lines, then call the helper method below to restart the level.

```csharp
    else
    {
      StartLevel();
    }
  }
```

This is a public method that another component may call in order to indicate that the win condition for the level has been met.

```csharp
  public void YouWin()
  {
```

If the game has already ended, return so not to trigger end of level effects twice.

```csharp
    if(isGameOver == true)
    {
      return;
    }
```

The player has won, here we track that the game is now over.

```csharp
    isGameOver = true;
```

This is a placeholder we will fill in later in the tutorial, for the end of game sequence to play when you win.

```csharp
    // TODO
  }
```

This is the helper method to start or restart the level.

```csharp
  void StartLevel()
  {
```

This will create a copy of the Character prefab and add it to the scene.

```csharp
    Instantiate(characterPrefab);
  }
```

This is the helper method which is called when the player has lost the game.

```csharp
  void YouLose()
  {
```

This is a placeholder we will fill in later in the tutorial, for the end of the game sequence to play when you lose.

```csharp
    // TODO
  }
}
```

</details>
<details><summary>Why does position before saving the prefab matter?</summary>

As a simplification, when the GameController spawns in the Character, we reuse the prefabs Transform position (and rotation/scale).  This is the default behaviour when you Instantiate from a prefab.

To be more flexible, we could have a default position for the Character defined somewhere for that level - allowing the spawn location to vary level to level.

<hr></details>

## 7.5) Clear Level on Death

[YouTube]() | [Source before](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerRespawn.zip) | [Source after](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerClearLevel.zip)

<details><summary>How</summary>

**Create PlayerDeathMonoBehaviour**:

 - Create script Code/Death/**[PlayerDeathMonoBehaviour](https://github.com/hardlydifficult/2DUnityTutorial/blob/GameControllerClearLevel/Assets/Code/Death/PlayerDeathMonoBehaviour.cs)**:

```csharp
using UnityEngine;

public abstract class PlayerDeathMonoBehaviour : MonoBehaviour
{
  public abstract void OnPlayerDeath();
}
```

<br>**Update LevelController**:

<details><summary>Existing code</summary>

```csharp
using UnityEngine;

public class LevelController : MonoBehaviour
{
  [SerializeField]
  GameObject characterPrefab;

  bool isGameOver;
  
  protected void Start()
  {
    GameController.instance.onLifeCountChange
      += Instance_onLifeCounterChange;

    StartLevel();
  }

  protected void OnDestroy()
  {
    GameController.instance.onLifeCountChange
      -= Instance_onLifeCounterChange;
  }

  void Instance_onLifeCounterChange()
  {
    if(isGameOver)
    {
      return;
    }
```

<hr></details>

```csharp
    BroadcastPlayerDied();
```

<details><summary>Existing code</summary>

```csharp
    if(GameController.instance.lifeCount <= 0)
    {
      isGameOver = true;
      YouLose();
    }
    else
    {
      StartLevel();
    }
  }

  public void YouWin()
  {
    if(isGameOver == true)
    {
      return;
    }
    isGameOver = true;

    // TODO
  }

  void StartLevel()
  {
    Instantiate(characterPrefab);
  }
```

<hr></details>

```csharp
  void BroadcastPlayerDied()
  {
    PlayerDeathMonoBehaviour[] gameObjectList
      = GameObject.FindObjectsOfType<PlayerDeathMonoBehaviour>();
    for(int i = 0; i < gameObjectList.Length; i++)
    {
      PlayerDeathMonoBehaviour playerDeath = gameObjectList[i];
      playerDeath.OnPlayerDeath();
    }
  }
```

<details><summary>Existing code</summary>

```csharp


  void YouLose()
  {
    // TODO
  }
}
```

<hr></details>

<br>**Create DestroyWhenPlayerDies**:

 - Create script Components/Death/**DestroyWhenPlayerDies**:

```csharp
public class DestroyWhenPlayerDies : PlayerDeathMonoBehaviour
{
  public override void OnPlayerDeath()
  {
    Destroy(gameObject);
  }
}
```

<br>**Configure entities**:

 - Add **DestroyWhenPlayerDies** to the HoverGuy and the SpikeBall prefabs.

<br>**Test**:

 - When the Character dies, all enemies should die as well.

<hr></details><br>
<details><summary>Explain the code</summary>


**PlayerDeathMonoBehaviour**:

using clauses at the top of a file brings APIs into scope. Used for:

 - UnityEngine.MonoBehaviour

```csharp
using UnityEngine;
```

We inherit from MonoBehaviour, which allows this script to be added as a component on a GameObject. 

public is optional here. Used for consistency.

```csharp
public abstract class PlayerDeathMonoBehaviour : MonoBehaviour
{
```

This is a method which must be implemented by classes which inherit from PlayerDeathMonoBehaviour. Called by the LevelManager when the player dies and should not be called directly.

```csharp
  public abstract void OnPlayerDeath();
}
```

<br>**LevelController**:

This calls a helper method below which will inform all PlayerDeathMonoBehaviours that the player has died.

```csharp
 BroadcastPlayerDied();
```

This is the helper method to inform all PlayerDeathMonoBehaviours that the player has died.

```csharp
  void BroadcastPlayerDied()
  {
```

Find every component in the scene which inherits from PlayerDeathMonoBehaviour.

```csharp
    PlayerDeathMonoBehaviour[] gameObjectList
      = GameObject.FindObjectsOfType<PlayerDeathMonoBehaviour>();
```

Loop over each of the components found.

```csharp
    for(int i = 0; i < gameObjectList.Length; i++)
    {
```

Here we call the method for this component to react to the player's death.

```csharp
      PlayerDeathMonoBehaviour playerDeath = gameObjectList[i];
      playerDeath.OnPlayerDeath();
    }
  }
```

<br>**DestroyWhenPlayerDies**:

We inherit from MonoBehaviour, which allows this script to be added as a component on a GameObject. 

public is optional here. Used for consistency.

```csharp
public class DestroyWhenPlayerDies : PlayerDeathMonoBehaviour
{
```

This overrides PlayerDeathMonoBehaviour's method which will be called when the player has died.

```csharp
  public override void OnPlayerDeath()
  {
```

This will destroy this GameObject, removing it from the scene.

```csharp
    Destroy(gameObject);
  }
}
```

</details>
<details><summary>Why not use an interface instead of abstract?</summary>

An interface would have been appropriate to use in this use case.  However Unity currently does not have an API for FindObjectsOfType for an interface.  You can work around this by getting all the GameObjects and then calling GetComponents, which does work with interfaces - but that is not an efficient solution.

<hr></details>
<details><summary>What does FindObjectsOfType do?</summary>

Unity offers a few similar calls allowing you to find all components attached to any GameObject in the scene.

We are using FindObjectsOfType to get an array of every component which inherited from PlayerDeathMonoBehaviour.  This call won't return components on an inactive GameObject but you could use FindObjectsOfTypeAll if you needed that.

Unity's Find* calls are very slow.  You should not use this frequently, such as every Update.  Depending on the use case, you may be able to collect the information just once OnEnable, or only periodically like we do here only when the player dies.

If you find the need to call Find* frequently, look for an alternative solution.  For example you may be able to create a static list of relevant references and have objects add/remove themselves as appropriate.

<hr></details>
<details><summary>Why not have all objects subscribe to life count changes instead or this new pattern?</summary>

There is a performance consideration, but this game likely would work fine either way.  I wanted to introduce another pattern for the tutorial to expose you to multiple possible solutions.

There is some overhead with subscribing and unsubscribing to events.  And as more and more objects subscribe to the same event, each sub and unsub is slower.  We are removing this overhead from the gameplay entirely by using this approach.

Find* is much slower overall, but in this use case it does not happen until after gameplay has ended - so losing a frames would not be as impactful.

<hr></details>

## 7.6) Points for Jumping Over Enemies

[YouTube]() | [Source before](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerClearLevel.zip) | [Source after](https://github.com/hardlydifficult/2DUnityTutorial/archive/GameControllerPoints.zip)

Add a collider and script to award points anytime the character jumps over an enemy.

<details><summary>How</summary>

**Create AwardPointsOnJumpOver**:

 - Create script Code/Effects/**[AwardPointsOnJumpOver](https://github.com/hardlydifficult/2DUnityTutorial/blob/GameControllerPoints/Assets/Code/Effects/AwardPointsOnJumpOver.cs)**:

```csharp
using UnityEngine;

[RequireComponent(typeof(BoxCollider2D))]
public class AwardPointsOnJumpOver : MonoBehaviour
{
  [SerializeField]
  int pointsToAward = 100;

  [SerializeField]
  float cooldownTime = 3;

  BoxCollider2D myCollider;

  [SerializeField]
  ContactFilter2D obstacleContactFilter;

  [SerializeField]
  LayerMask playerLayerMask;

  static readonly RaycastHit2D[] tempHitList = new RaycastHit2D[1];

  float lastPickupTime;

  protected void Awake()
  {
    myCollider = GetComponent<BoxCollider2D>();
  }

  protected void OnTriggerStay2D(
    Collider2D collision)
  {
    if(Time.timeSinceLevelLoad - lastPickupTime < cooldownTime)
    {
      return;
    }

    int count = Physics2D.Raycast(
      transform.parent.position,
      Vector2.up,
      obstacleContactFilter,
      tempHitList);

    if(count > 0
      && playerLayerMask.Includes(
        tempHitList[0].collider.gameObject.layer))
    {
      GameController.instance.points += pointsToAward;

      lastPickupTime = Time.timeSinceLevelLoad;
    }
  }
}
```

<br>**Create HoldRotation**:

 - Create script Code/Movement/**[HoldRotation](https://github.com/hardlydifficult/2DUnityTutorial/blob/GameControllerPoints/Assets/Code/Movement/HoldRotation.cs)**:

```csharp
using UnityEngine;

public class HoldRotation : MonoBehaviour
{
  Quaternion originalRotation;

  protected void Awake()
  {
    originalRotation = transform.rotation;
  }

  protected void FixedUpdate()
  {
    transform.rotation = originalRotation;
  }
}
```

<br>**Create Layers**:

 - Create a new Layer for "Floor"
 - Select all of the Platform GameObjects
   - Assign layer Floor.
 - Create a new Layer for "Points"
   - In the Collision Matrix: disable all collisions with Points except for Points / Character collisions.

<img src="https://i.imgur.com/IpwsPyo.png" width=150px />
   
<br>**Configure entities**:

Add the HoverGuy and SpikeBall to scene and for each:

  - Add a new empty GameObject as a child:
    - Name it "Points".
    - Add **AwardPointsOnJumpOver** (which automatically adds **BoxCollider2D**):
      - Obstacle Contact Filter:
        - Check Use Triggers.
        - Check Use LayerMask.
        - LayerMask: Character and Floor
     - Player Layer Mask: Character
     - Box collider:
       - Check Is Trigger.
       - Size the collider to capture the area above the entity.

<img src="https://i.imgur.com/gmMDJlD.png" width=150px />

  - Assign it the Points layer.
  - Add **HoldRotation**.
  - Add a **Rigidbody2D**:
    - Change the Body Type to 'Kinematic'.
 - Apply changes to the prefab and delete the GameObject.

<br>**Test**:

 - When the Character jumps over an enemy, 100 points are awarded.
    - Confirm the point value by looking at the GameController in the Inspector.
   - Check with both HoverGuy and SpikeBall.
 - Stand on a platform above enemies and confirm you do not get points when they travel under.

<hr></details><br>
<details><summary>Explain the code</summary>

**AwardPointsOnJumpOver**:

using clauses at the top of a file brings APIs into scope. Used for:

 - UnityEngine.BoxCollider2D
 - UnityEngine.Collider2D
 - UnityEngine.ContactFilter2D
 - UnityEngine.LayerMask
 - UnityEngine.MonoBehaviour
 - UnityEngine.Physics2D
 - UnityEngine.RaycastHit2D
 - UnityEngine.RequireComponentAttribute
 - UnityEngine.SerializeFieldAttribute
 - UnityEngine.Time

```csharp
using UnityEngine;
```

This is a Unity-specific attribute which informs the editor that this script requires a box collider component on the GameObject.

```csharp
[RequireComponent(typeof(BoxCollider2D))]
```

We inherit from MonoBehaviour, which allows this script to be added as a component on a GameObject.

public is optional here. Used for consistency.

```csharp
public class AwardPointsOnJumpOver : MonoBehaviour
{
```

This is a Unity-specific attribute that exposes a field in the Inspector, allowing you to configure it for the object.

```csharp
  [SerializeField]
```

This defines how many points to award the player when they jump over.  Set in the Inspector.

```csharp
  int pointsToAward = 100;
```

This defines how long before you can get points by jumping over this GameObject again.  Set in the Inspector.

```csharp
  [SerializeField]
  float cooldownTime = 3;
```

This is a reference to the box collider on this GameObject.  Cached here for performance.

```csharp
  BoxCollider2D myCollider;
```

This defines which GameObjects should be considered when checking above the entity to determine if points should be awarded.  This must include the Character, but should also include anything that would prevent points such as a Platform which may be sitting between the enemy and the Character.  Set in the Inspector.

```csharp
  [SerializeField]
  ContactFilter2D obstacleContactFilter;
```

This defines the layer(s) for the player.  Used to ensure other GameObject types do not trigger awarding points.  Set in the Inspector.

```csharp
  [SerializeField]
  LayerMask playerLayerMask;
```

This is a list to use when calling Raycast.  Here so that we can reuse the array each time, improving performance.

It is static readonly since we only need one, which can be shared across objects and the array itself will never change.

```csharp
  static readonly RaycastHit2D[] tempHitList = new RaycastHit2D[1];
```

This stores the last time points were awarded by this component / GameObject.  Used to implement a cooldown, allowing you to jump over an enemy for points again after a few seconds.

```csharp
  float lastPickupTime;
```

Awake is a Unity method which is called once, when the GameObject is first added to the scene.

protected is optional here.  Used for consistency.

```csharp
  protected void Awake()
  {
```

Here we get a reference to the box collider on this GameObject.

```csharp
    myCollider = GetComponent<BoxCollider2D>();
  }
```

OnTriggerStay2D is a Unity method which is called each FixedUpdate for each collider that is overlapping a collider on this GameObject.

```csharp
  protected void OnTriggerStay2D(
    Collider2D collision)
  {
```

Check if the time since the last time we awarded points is less than the cooldownTime.  If it is we return so not to execute the logic below.

```csharp
    if(Time.timeSinceLevelLoad - lastPickupTime < cooldownTime)
    {
      return;
    }
```

This checks for GameObjects at this GameObject's location, or above.  The obstacleContactFilter defines which GameObjects types to consider.  

count here represents the number of GameObjects found above this.

If any GameObjects were found, tempHitList[0] will store a reference to its collider.

```csharp
    int count = Physics2D.Raycast(
      transform.parent.position,
      Vector2.up,
      obstacleContactFilter,
      tempHitList);
```

Check if any GameObjects were found, and if they were check if the first GameObject encountered is the player.

If the first is the player, than points should be awarded.  Otherwise, there is something like a Platform in between them and points should not be awarded.

```csharp
    if(count > 0
      && playerLayerMask.Includes(
        tempHitList[0].collider.gameObject.layer))
    {
```

Here we award points by updating the value in the GameController.

```csharp
      GameController.instance.points += pointsToAward;
```

Here we set the lastPickupTime, enabling the cooldown check above.

```csharp
      lastPickupTime = Time.timeSinceLevelLoad;
    }
  }
}
```

<br>**HoldRotation**:

using clauses at the top of a file brings APIs into scope. Used for:

 - UnityEngine.MonoBehaviour
 - UnityEngine.Quaternion

```csharp
using UnityEngine;
```

We inherit from MonoBehaviour, which allows this script to be added as a component on a GameObject.

public is optional here. Used for consistency.

```csharp
public class HoldRotation : MonoBehaviour
{
```

This stores the original rotation for the GameObject, as it was defined in the prefab or scene.  Used as the rotation to set each FixedUpdate.

```csharp
  Quaternion originalRotation;
```

Awake is a Unity method which is called once, when the GameObject is first added to the scene.

```csharp
  protected void Awake()
  {
```

Here we store the original rotation for the GameObject, as it was defined in the prefab or scene.

```csharp
    originalRotation = transform.rotation;
  }
```

FixedUpdate is a Unity method which is called every x ms of game time.

protected is optional here.  Used for consistency.

```csharp
  protected void FixedUpdate()
  {
```

Here we set the rotation back to its original.

By using .rotation instead of .localRotation, we are actually setting this GameObject's rotation to a value that discounts any rotation the parent GameObject has.

```csharp
    transform.rotation = originalRotation;
  }
}
```

</details>
<details><summary>What's Raycast do?</summary>

Raycast projects a line and returns colliders intersecting with it (in order, closest first).  There are other 'cast' calls to project different shapes when needed, e.g., BoxCast.

When Raycasting, there are various options available.  Here we provide an origin point for the line and the direction its pointing.  The contact filter defines which objects to include in the results - when using Raycast, it does not consider your configuration in the collision matrix.

<hr></details>
<details><summary>Why Trigger AND Raycast?</summary>

The trigger informs us when there is a player above the enemy.  However, this does not consider any platforms which are also above us.  The raycast is used to determine what is directly above the enemy, and we only award points if it's the player.

Ultimately the raycast here answers the question of when to award points.  We could raycast each frame in an update loop, but instead leverage the trigger to improve performance by only checking when the player is near.

<hr></details>
<details><summary>Why add another Rigidbody2D / why check the collision layer manually?</summary>

When you are using a child GameObject, adding another Rigidbody2D will ensure that physics events from the child do not reach the parent.  i.e., any scripts on the parent would not get an OnTriggerEnter or OnCollisionStay call for a collider on the child this way -- in this tutorial the KillOnContact script may trigger much too soon without the second Rigidbody2D.

The second Rigidbody2D does not prevent events on the parent from reaching any scripts on the child GameObject.  In AwardPointsOnJumpOver, after a trigger we will raycast to confirm the player is directly above us - with this the additional events from the parent do not impact gameplay.

<hr></details>
<details><summary>Do we need a cooldown?</summary>

Yes, as the code is currently written.  Removing the cooldown would result in huge payouts as the player jumped over.

This could be addressed other ways.  Consider exactly when you would want to award more points for jumping over an enemy. e.g., we allow you to move back and forth while in the air - if I did this over an enemy, should I get paid twice?

<hr></details>
<details><summary>Why hold rotation on the Points child GameObject?</summary>

Each FixedUpdate, we set the rotation back to the original. We add this to the points child on the SpikeBall to ensure we are always checking for the player straight up.

Without this, the points collider would spin with the parent ball.

<hr></details>
<details><summary>Why FixedUpdate instead of Update here?</summary>

Update runs each frame.  Changing the Transform each Update may be appropriate when you are making changes the player will see.

FixedUpdate runs every x ms of game time.  Changing the Transform each FixedUpdate can be used to impact the physics, such as collision detection.

It is possible for FixedUpdate to happen twice between Updates.  For this use case, we are only interested in freezing the position for the purpose of trigger enter events.  If we were to change the transform each Update, we would be checking for collisions with some rotation.  That said, this probably would not be noticeable for this use case - just noting that using Update instead FixedUpdate is a tiny bit incorrect.

<hr></details>

## To Review

<details><summary>Testing / debugging tips</summary>

 - TODO

</details>

## Up Next

[**Chapter 8** Ground Detection](C8.md)

<br><hr>

Questions, issues, or suggestions?  Please use the YouTube comments for the best fit section.

Support on [Patreon](https://www.patreon.com/HardlyDifficult), with [Paypal](https://u.muxy.io/tip/HardlyDifficult), or by subscribing on [Twitch](https://www.twitch.tv/HardlyDifficult) (free with Amazon Prime).

[License](TODO). Created live at [twitch.tv/HardlyDifficult](https://www.twitch.tv/HardlyDifficult) August 2017.