[Outline](README.md) | Previous: [Character Animations](C11.md) | Next: [Level Won Timeline](C13.md)

# 12) Intro Timeline

TODO



## 12.1) Intro Animation

[YouTube]() | [Source before](https://github.com/hardlydifficult/2DUnityTutorial/archive/11_5_Breakdance.zip) | [Source after](https://github.com/hardlydifficult/2DUnityTutorial/archive/12_1_IntroAnimation.zip)

Create an animation for the cloud entrance at the start of the level.

Create a timeline which enables the LevelController and Hammers after the intro is complete.

<details><summary>How</summary>

**Intro animation**:

 - Create an animation for the EvilCloud's sprite Animations/**CloudLevel1Entrance**.anim
   - Click record:
     - Start by moving the cloud off-screen.
     - Then over time, modify its position to create a dramatic entrance.
     - The timeline should end with the cloud at position 0 (the starting position at the top left).
 - Select the file Animations/CloudLevel1Entrance:
   - In the Inspector uncheck 'Loop Time'.

<br>Intro timeline:

 - Open menu Window -> Timeline Editor.
 - Select the EvilCloud's sprite.
   - Click 'Create'.  Save as Animations/**Level1Entrance**.playable
   - Select 'Add from Animation Clip' and select CloudLevel1Entrance.

<img src="https://i.imgur.com/7HXZs7Z.gif" width=300px />

 - Select the clip just added and in the Inspector:
    - Speed: .1 
    - Hit play in the Timeline Editor and adjust the speed for your animation.
 - Drag the parent Hammers GameObject (which holds all the hammers) onto the timeline and select **Activation Track**.
   - Move the box for the script so that it starts after the cloud animation completes.  
     - The start of the box represents when it will be enabled.
     - The end must align with the end of the time timeline to prevent it from being disabled.

<img src="https://i.imgur.com/6XyJZlh.gif" width=300px />

 - Repeat, creating activation tracks for the LevelController and the Ladders.
 - Close the Timeline Editor window.
 - Disable the GameObjects: LevelController, Ladders, and Hammers.

<br>**Test**:

 - The cloud's animation should complete and then the ladders, hammers, and character fade in.  
   - Enemies will spawn before the intro completes, this will be fixed next.

<hr></details><br>
<details><summary>What is a Unity Timeline / Activation Track?</summary>

Timeline is a new feature released with Unity 2017.  It's a higher level component than the Animator Controller, used to coordinate animations and trigger events across several objects in the scene with an interface that resembles the Animation timeline.

Previously, achieving similiar results would have required a script.  Now you can manage the sequence visually if you prefer.

'Add Animation From Clip' plays an animation during the timeframe specified, overriding what the Animator controller for that object would have done.

Activation Tracks are one of several ways that you trigger behaviour with the Timeline.  An activation track will enable a GameObject where the track begins in the timeline, and disable it again where it ends.  If the activation track ends at the very end of the entire timeline then it will remain active after the timeline completes.

<hr></details>
<details><summary>How might we do this without using the Timeline Editor?</summary>

There are always alternative ways to achieve a goal, particularly true in this case since the Timeline Editor is brand new.

An alternative solution might be something like this:

 - For the EvilCloud, simply play the intro animation with a default state in the Animator Controller.
 - Add a 'InvisibleFor' value to the FadeInThenEnable script, and time that to coordinate with the intro.
 - Add an initial sleep time to the spawner to align with the intro animation.

The advantage to using the Timeline is as you make adjustments to the sequence, you can make those changes visually and aligning the time between objects may be easier.

<hr<hr></details>


## 12.2) Start Spawners After Intro

[YouTube]() | [Source before](https://github.com/hardlydifficult/2DUnityTutorial/archive/12_1_IntroAnimation.zip) | [Source after](https://github.com/hardlydifficult/2DUnityTutorial/archive/12_2_Spawners.zip)

Disable the spawners and create a script to later enable them when the level intro completes.

<details><summary>How</summary>

**Create EnableComponentsOnTimelineEvent**:

 - Create script Code/Animations/**[EnableComponentsOnTimelineEvent](https://github.com/hardlydifficult/2DUnityTutorial/blob/12_2_Spawners/Assets/Code/Animations/EnableComponentsOnTimelineEvent.cs)**:
   - Note there will be compile issues until TimelineEventPlayable is added.

```csharp
using UnityEngine;

public class EnableComponentsOnTimelineEvent : MonoBehaviour
{
  [SerializeField]
  TimelineEventPlayable.EventType eventType;

  [SerializeField]
  Behaviour[] componentListToEnable;

  public void OnEvent(
    TimelineEventPlayable.EventType currentEventType)
  {
    if(currentEventType == eventType)
    {
      for(int i = 0; i < componentListToEnable.Length; i++)
      {
        Behaviour component = componentListToEnable[i];
        component.enabled = true;
      }
    }
  }
}
```

<br>**Create TimelineEventPlayable**:

 - Create script Code/Animations/**[TimelineEventPlayable](https://github.com/hardlydifficult/2DUnityTutorial/blob/12_2_Spawners/Assets/Code/Animations/TimelineEventPlayable.cs)**:

```csharp
using UnityEngine;
using UnityEngine.Playables;
using UnityEngine.Timeline;

public class TimelineEventPlayable : BasicPlayableBehaviour
{
  public enum EventType
  {
    AlmostAtStart, Start, End
  }

  [SerializeField]
  EventType eventType;

  public override void OnBehaviourPlay(
    Playable playable,
    FrameData info)
  {
    base.OnBehaviourPlay(playable, info);

    EnableComponentsOnTimelineEvent[] componentList
      = GameObject.FindObjectsOfType<EnableComponentsOnTimelineEvent>();

    for(int i = 0; i < componentList.Length; i++)
    {
      EnableComponentsOnTimelineEvent component = componentList[i];
      component.OnEvent(eventType);
    }
  }
}
```

<br>**Configure spawners**:

 - For both the cloud and door:
   - Disable the **Spawner** component.
   - Add **EnableComponentsOnTimelineEvent**.
     - Event Type: Start
     - Add the Spawner component to its list.

<br>**Update Timeline**:

 - Open the Timeline Editor and select the EvilCloud's sprite.
 - Drag drop the **TimelineEventPlayable** script into the timeline.  
   - Set the time to start a bit after the Hammers and such activate, and align the ends.
   - In the Inspector, change the 'Event Type' to 'Start'.
 - Drag the script in a second time and set the time to fire a bit before the animation ends.

<img src="https://i.imgur.com/k3WQ1Ji.png" width=500px />

<br>**Test**:

 - Enemies should not spawn until after the intro animation completes.

<hr></details><br>
<details><summary>Explain the code</summary>

**EnableComponentsOnTimelineEvent**:

'using' clauses at the top of a file brings APIs into scope. Used for:

 - UnityEngine.Behaviour
 - UnityEngine.MonoBehaviour
 - UnityEngine.SerializeFieldAttribute

```csharp
using UnityEngine;
```

We inherit from MonoBehaviour, which allows this script to be added as a component on a GameObject.

public is optional here. Used for consistency.

```csharp
public class EnableComponentsOnTimelineEvent : MonoBehaviour
{
```

This is a Unity-specific attribute that exposes a field in the Inspector, allowing you to configure it for the object.

```csharp
  [SerializeField]
```

This defines which Timeline event will trigger enabling components.  Set in the Inspector.

```csharp
  TimelineEventPlayable.EventType eventType;
```

This defines the list of components to enable when the Timeline event occurs.  Set in the Inspector.

```csharp
  [SerializeField]
  Behaviour[] componentListToEnable;
```

This is a public method which will be called by the TimelineEventPlayable when any of the Timeline events occur.  It will pass in the current event type, and this method should ignore all but the event it's interested in.

```csharp
  public void OnEvent(
    TimelineEventPlayable.EventType currentEventType)
  {
```

Check if this is the event this component is interested in.

```csharp
    if(currentEventType == eventType)
    {
```

Loop over each of the components to enable.

```csharp
      for(int i = 0; i < componentListToEnable.Length; i++)
      {
        Behaviour component = componentListToEnable[i];
```

Enable the component.

```csharp
        component.enabled = true;
      }
    }
  }
}
```

<br>**TimelineEventPlayable**:

using clauses at the top of a file brings APIs into scope. Used for:

 - UnityEngine.GameObject
 - UnityEngine.Playables.FrameData
 - UnityEngine.Playables.Playable
 - UnityEngine.SerializeFieldAttribute
 - UnityEngine.Timeline.BasicPlayableBehaviour

```csharp
using UnityEngine;
using UnityEngine.Playables;
using UnityEngine.Timeline;
```

We inherit from BasicPlayableBehaviour which allows this script to be added to as an event in a Timeline.

public is optional here.  Used for consistency.

```csharp
public class TimelineEventPlayable : BasicPlayableBehaviour
{
```

This defines an enum of the possible event types this component may fire.

```csharp
  public enum EventType
  {
    AlmostAtStart, Start, End
  }
```

This defines which event this instance in the Timeline will trigger.  So you can this script to a Timeline and then in the Inspector change the event it will trigger.

```csharp
  [SerializeField]
  EventType eventType;
```

OnBehaviourPlay is a Unity event which is called when this script begins in a Timeline.

We are going to ignore the parameters here.

```csharp
  public override void OnBehaviourPlay(
    Playable playable,
    FrameData info)
  {
```

As a general best practice when override methods, we call the base first so that this script supplements instead of replaces any logic the basic class may have for this method.

```csharp
    base.OnBehaviourPlay(playable, info);
```

Find all EnableComponentsOnTimelineEvent in the scene.

```csharp
    EnableComponentsOnTimelineEvent[] componentList
      = GameObject.FindObjectsOfType<EnableComponentsOnTimelineEvent>();
```

Loop over each of the components found.

```csharp
    for(int i = 0; i < componentList.Length; i++)
    {
      EnableComponentsOnTimelineEvent component = componentList[i];
```

Call the EnableComponentsOnTimelineEvent's OnEvent method, allowing that component to react to the event if it's the correct type.

```csharp
      component.OnEvent(eventType);
    }
  }
}
```

</details>
<details><summary>What is a BasicPlayableBehaviour / when is OnBehaviourPlay called?</summary>

A BasicPlayableBehaviour is like a MonoBehaviour but for scripts to be used in the Timeline (vs on a GameObject directly).

OnBehaviourPlay is a Unity event called when the script begins on the timeline.  Note that here Unity uses override instead of the reflection pattern used with MonoBehaviour events.

<hr></details>
<details><summary>What's a C# 'enum'?</summary>

An enum is a set of named constants.  The constants are by default type int and count sequentially starting from 0.  For example:

```csharp
enum Example 
{
  A, B, C
}
```

is similiar to

```csharp
const int A = 0;
const int B = 1;
const int C = 2;
```

Enums are often used to bring a related set of constants together.  They have some additional benefits over listing the constants individually such as:

 - You can iterate all possible values using System.Enum.GetValues.
 - You can use ToString to get the named value.
 - Clarifies intent, making it easier to know what values should be accepted.

Consider using an enum if the set of values is known at compile time.

<hr></details>


## 12.3) Rotate Platforms

[YouTube]() | [Source before](https://github.com/hardlydifficult/2DUnityTutorial/archive/12_2_Spawners.zip) | [Source after]()

Platforms start out straight and then when the intro animation is nearly complete, shake down into position.

<details open><summary>How</summary>

**Create RotateOvertimeToOriginal**:

 - Create script Code/Animations/**RotateOvertimeToOriginal**:

```csharp
using System.Collections;
using UnityEngine;

public class RotateOvertimeToOriginal : MonoBehaviour
{
  [SerializeField]
  float rotationFactor = 1;

  [SerializeField]
  float maxTimeBetweenRotations = .25f;

  Quaternion targetRotation;

  protected void Awake()
  {
    targetRotation = transform.rotation;
    transform.rotation = Quaternion.identity;
  }

  protected void Start()
  {
    StartCoroutine(AnimateRotation());
  }

  IEnumerator AnimateRotation()
  {
    float percentComplete = 0;
    float sleepTimeLastFrame = 0;
    while(true)
    {
      sleepTimeLastFrame 
        = UnityEngine.Random.Range(0, maxTimeBetweenRotations);
      yield return new WaitForSeconds(sleepTimeLastFrame);
      sleepTimeLastFrame = Mathf.Max(Time.deltaTime, sleepTimeLastFrame);

      float percentCompleteThisFrame = sleepTimeLastFrame * rotationFactor;
      percentCompleteThisFrame *= UnityEngine.Random.Range(0, 10);
      percentComplete += percentCompleteThisFrame;
      if(percentComplete >= 1)
      {
        transform.rotation = targetRotation;
        yield break;
      }
      transform.rotation = Quaternion.Lerp(
        Quaternion.identity, 
        targetRotation, 
        percentComplete);
    }
  }
}
```

<br>**Configure Platforms**:

 - For each Platform:
   - Add **RotateOvertimeToOriginal**:
     - Disable the component.
   - Add **EnableComponentsOnTimelineEvent**:
     - Add RotateOvertimeToOriginal to the 'Components to enable on almost loaded'.

<br>**Test**:

 - The platforms should shake into place when the intro is nearly complete.
   - Adjust the starting position for the Almost At Start event in the Timeline so the platforms shake at a good point in the animation.

<hr></details><br>
<details><summary>What's C# yield break do?</summary>

Enumerators are methods which can 'yield return' and then later be resumed from where they left off.  Coroutines in Unity are enumerators.  

When working with enumerators, 'yield break' will return from the method and indicate that it's complete and cannot be resumed again.

<hr></details>

## 12.4) Add screen shake during intro

[YouTube]() | [Source before]() | [Source after]()

Shake the screen when the platforms fall into place.

<details><summary>How</summary>

 - Create script Components/Animations/**ScreenShake**:

```csharp
using System.Collections;
using UnityEngine;

public class ScreenShake : MonoBehaviour
{
  [SerializeField]
  float timeToShakeFor = 1;

  [SerializeField]
  float maxTimeBetweenShakes = .2f;

  [SerializeField]
  float shakeMagnitude = 1;

  protected void Start()
  {
    StartCoroutine(ShakeCamera());
  }

  IEnumerator ShakeCamera()
  {
    Camera camera = Camera.main;
    Vector3 startingPosition = camera.transform.position;

    float timePassed = 0;
    while(timePassed < timeToShakeFor)
    {
      float percentComplete = timePassed / timeToShakeFor;
      percentComplete *= 2;
      if(percentComplete > 1)
      {
        percentComplete = 2 - percentComplete;
      }
      Vector2 deltaPosition 
        = UnityEngine.Random.insideUnitCircle * shakeMagnitude * percentComplete;
      camera.transform.position = startingPosition + (Vector3)deltaPosition;

      float maxTime = maxTimeBetweenShakes * (1 - percentComplete);
      float sleepTime 
        = UnityEngine.Random.Range(0, maxTime);
      yield return new WaitForSeconds(sleepTime);
      sleepTime = Mathf.Max(Time.deltaTime, sleepTime);
      timePassed += sleepTime;
    }

    camera.transform.position = startingPosition;
  }
}
```

 - Select the camera:
   - Add **ScreenShake** and disable the component.
   - Add **EnableComponentsOnLevelLoad**.
     - Event Type: Almost At Start
     - Add its ScreenShake component to the component list.

<hr></details><br>
<details><summary>What did that do?</summary>

ScreenShake moves the camera up/down/left/right randomly to create a shaking effect.  The effect lasts for a limited time and scales up in magnitude (i.e., the intensity of the shake) and then back down.  This component is enabled when the intro Timeline is almost complete, and that event aligns with the cloud bouncing - making it look like the cloud is shaking the platforms into place.

<hr></details>
<details><summary>What is the script doing with percent complete?</summary>

Our goal is to smoothly transition from 0 to 1 and then back to 0.  We use this value as a multiple on how much we move the camera that frame - smoothing the start and end of the effect.

We do this by doubling the percent complete and then if greater than 1, use 2 - the value.  This gives us the desired 0 -> 1 -> 0 curve.

<hr></details>
<details><summary>What does Random.insideUnitCircle do?</summary>

Random.insideUnitCircle is a convenience method giving you a random point which falls on a circle with a radius of 1.  We take that value and then multiple it by the desired magnitude, effectively giving us a random point on a larger, or smaller, circle; and then position that the camera that far from its original position.

<hr></details>
<details><summary>What else could we add to the shake effect?</summary>

Here are a few ideas on how you might be able to make this effect even cooler:

 - Randomly change the z Rotation in addition to the position.
 - Randomly change the orthographic size, causing the camera to zoom in and out.
 - The current shake algorithm is uses a random offset from the camera's original position, you may be able to improve the effect by giving consideration to the camera position the previous frame.
 - Add a post processing effect such as blur.  Post processing effects refer to scripts you can add to your camera, modifying the display to create an effect such as blur or bloom.  Here are some [post processing effects, free from Unity](https://www.assetstore.unity3d.com/en/#!/content/83912), you can use.

<hr></details>
          
## To Review

<details><summary>Testing / debugging tips</summary>

 - TODO

</details>

## Up Next

[**Chapter 13** Level Won Timeline](C13.md)

<br><hr>

Questions, issues, or suggestions?  Please use the YouTube comments for the best fit section.

Support on [Patreon](https://www.patreon.com/HardlyDifficult), with [Paypal](https://u.muxy.io/tip/HardlyDifficult), or by subscribing on [Twitch](https://www.twitch.tv/HardlyDifficult/subscribe) (free with Amazon Prime).

[License](TODO). Created live at [twitch.tv/HardlyDifficult](https://www.twitch.tv/HardlyDifficult) August 2017.